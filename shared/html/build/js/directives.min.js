'use strict';

app.directive('clickOutside', ['$document', '$parse', '$timeout', function ($document, $parse, $timeout) {
    return {
        restrict: 'A',
        link: function($scope, elem, attr) {

            // postpone linking to next digest to allow for unique id generation
            $timeout(function() {
                var classList = (attr.outsideIfNot !== undefined) ? attr.outsideIfNot.split(/[ ,]+/) : [],
                    fn;

                // add the elements id so it is not counted in the click listening
                if (attr.id !== undefined) {
                    classList.push(attr.id);
                }

                function eventHandler(e) {
                    var i,
                        element,
                        r,
                        id,
                        classNames,
                        l;

                    // check if our element already hidden and abort if so
                    if (angular.element(elem).hasClass("ng-hide")) {
                        return;
                    }

                    // if there is no click target, no point going on
                    if (!e || !e.target) {
                        return;
                    }

                    // loop through the available elements, looking for classes in the class list that might match and so will eat
                    for (element = e.target; element; element = element.parentNode) {
                        id = element.id,
                        classNames = element.className,
                        l = classList.length;

                        // Unwrap SVGAnimatedString classes
                        if (classNames && classNames.baseVal !== undefined) {
                            classNames = classNames.baseVal;
                        }

                        // if there are no class names on the element clicked, skip the check
                        if (classNames || id) {

                            // console.log('classNames: ' + classNames);

                            // loop through the elements id's and classnames looking for exceptions
                            for (i = 0; i < l; i++) {
                                //prepare regex for class word matching
                                r = new RegExp('\\b' + classList[i] + '\\b');

                              //  console.log('classList: ' + classList[i]);

                                // check for exact matches on id's or classes, but only if they exist in the first place
                                if ((id !== undefined && id === classList[i]) || (classNames && r.test(classNames))) {
                                    // now let's exit out as it is an element that has been defined as being ignored for clicking outside
                                    return;
                                }
                            }
                        }
                    }

                    // if we have got this far, then we are good to go with processing the command passed in via the click-outside attribute
                    $scope.$apply(function() {
                        fn = $parse(attr['clickOutside']);
                        fn($scope);
                    });
                }

                // if the devices has a touchscreen, listen for this event
                if (_hasTouch()) {
                    $document.on('touchstart', eventHandler);
                }

                // still listen for the click event even if there is touch to cater for touchscreen laptops
                $document.on('click', eventHandler);

                // when the scope is destroyed, clean up the documents event handlers as we don't want it hanging around
                $scope.$on('$destroy', function() {
                    if (_hasTouch()) {
                        $document.off('touchstart', eventHandler);
                    }

                    $document.off('click', eventHandler);
                });

                // private function to attempt to figure out if we are on a touch device
                function _hasTouch() {
                    // works on most browsers, IE10/11 and Surface
                    return 'ontouchstart' in window || navigator.maxTouchPoints;
                };
            });
        }
    };
}]);
'use strict';

app.directive('ngConfirmClick', [function () {
    return {
        link: function (scope, element, attr) {
            var msg = attr.ngConfirmClick || "Are you sure?";
            var clickAction = attr.confirmedClick;
            element.bind('click', function (event) {
                if (window.confirm(msg)) {
                    scope.$eval(clickAction)
                }
            });
        }
    };
}]);
(function () {

    function processIds(self, ids) {
        var actualIds = [];
        if (ids && ids.length > 0) {
            ids.forEach(function (rowId) {
                var rowObject = $(self).getRowData(rowId);
                if (rowObject)
                    actualIds.push(rowObject._id);
            });
        }
        return actualIds;
    };


    app.directive('ngJqGridImportContact', function ($compile) {
        return {
            restrict: 'E',
            scope: {
                config: '=',
                data: '=',
                columnmodelruntime: '=',
                mycontactdbcolumns: '=',
            },
            link: function (scope, element, attrs) {
                var table;
                var id = attrs.id;

                scope.$watch('config', function (newValue) {
                    element.children().empty();
                    table = angular.element('<table id="tableid"></table>');
                   
                    element.append(table);
                    newValue.onSelectAll = function (ids, status) {
                        var actualIDs = processIds(this,ids);
                        $(this).scope().onSelectAll($(this).scope(), status, actualIDs);
                    };

                    newValue.onSelectRow = function (row, status, elem) {
                        $(this).scope().onSelectRow($(this).scope(), status, $(this).getRowData(row)._id);
                    };
                
                    $(table).jqGrid(newValue);
                });

                scope.$watch('data', function (newValue, oldValue) {
                    var i;
                    for (i = oldValue.length - 1; i >= 0; i--) {
                        $(table).jqGrid('delRowData', i);
                    }
                    for (i = 0; i < newValue.length; i++) {
                        $(table).jqGrid('addRowData', i, newValue[i]);
                        if (newValue[i].is_active) {
                            $(table).jqGrid('resetSelection', i,true);
                            $(table).jqGrid('setSelection', i, true);
                        } else {
                            $(table).jqGrid('resetSelection', i,false);
                        }
                    }
                });
                scope.$watch('mycontactdbcolumns', function (dbColumnValues) {
                    scope.filedMappingData = {};
                    scope.filedMappingData.myContactDBFields = [];

                    var tempObjIgnore = {};
                    tempObjIgnore.value = "ignore";
                    tempObjIgnore.name = "Ignore";
                    scope.filedMappingData.myContactDBFields.push(tempObjIgnore);

                    angular.forEach(dbColumnValues, function (value, key) {
                        var tempObj = {};
                        tempObj.value = value.field_value;
                        tempObj.name = value.display_name;
                        scope.filedMappingData.myContactDBFields.push(tempObj);
                    });
                   
                });

                scope.$watch('columnmodelruntime', function (ColumnValues) {

                    if (ColumnValues.length < 1 ) {
                        return;
                    }
                    $("#gbox_tableid").remove();
                    var grpHeaders = [];
                    var headerObj = {};
                    if (!scope.filedMappingData) {
                        scope.filedMappingData = {};
                        scope.filedMappingData.myContactDBFields = [];
                    }
                    angular.forEach(ColumnValues, function (value, key) {
                        var ele = '<select ng-model="columnmodelruntime[' + key + '].value" ng-options="mapping.name for mapping in filedMappingData.myContactDBFields track by mapping.value"><option value="">Save to Comment</option></select>';
                        headerObj = {};
                        headerObj.startColumnName = value.name;
                        headerObj.numberOfColumns = 1;
                        headerObj.titleText = $compile(ele)(scope);
                        grpHeaders.push(headerObj);
                    });

                    $("#tableid").jqGrid('setGroupHeaders', {
                        useColSpanStyle: false,
                        groupHeaders: grpHeaders
                    });

                });
            }
        };
    });
})();
(function () {

    'use strict';

    var gridHeight = '';
    var gridWidth = '';

    function processIds(self, ids) {
        var actualIds = [];
        if (ids && ids.length > 0) {
            ids.forEach(function (rowId) {
                var rowObject = $(self).getRowData(rowId);
                if (rowObject)
                    actualIds.push(rowObject._id);
            });
        }
        var scp = $(self).scope();
        scp.selected.gridSelectedRows = actualIds;
        //if (!scp.$$phase)
        //    scp.$apply();
    };

   
    app.directive('gridManageAccount', ['$cookies', '$compile', function ($cookies, $compile) {
        return {
            restrict: 'E',
            scope: {
                config: '=',
            },
            link: function (scope, element, attrs) {
                var table;
                var pager;
                var id = attrs.idElm;
                scope.$watch('config', function (newValue) {
                    if (newValue) {
                        $('#' + id).remove();
                        element.children().empty();
                        table = angular.element('<table id="' + id + '"></table>');
                        element.append(table);
                        newValue.viewrecords = true;
                        newValue.altRows = true;
                        newValue.shrinkToFit = false;
                        newValue.autowidth= true,
                     
                        newValue.onSelectAll = function (ids, status) {
                            if(status == true){
                                $(this).scope().selected.gridSelectedRows = ids;
                            } else {
                                $(this).scope().selected.gridSelectedRows = [];
                            }
                           
                         //   $(this).scope().onSelectAllManageAccount($(this).scope(), status, actualIDs);
                        };

                        newValue.onSelectRow = function (row, status, elem) {
                            var ids = $(this).jqGrid('getGridParam', 'selarrrow');
                            processIds(this, ids);
                           // $(this).scope().onSelectRowManageAccout($(this).scope(), status, $(this).getRowData(row)._id);
                        };

                        newValue.onCellSelect = function (rowid, iCol, cellcontent, e) {
                            if (iCol == 3) {
                                $(this).scope().onLastImportedTimeUpdate($(this).getRowData(rowid)._id);
                            }
                            if (iCol == 5) {
                               // $(this).scope().googleLogin();
                                $(this).scope().OnDisconnectButtonCloseManageAccountDailog($(this).getRowData(rowid).last_sync_status);
                            }
                            if (iCol == 6) {
                                var tempArray = [];
                                tempArray.push($(this).getRowData(rowid)._id);
                                $(this).scope().syncDeleteAccountGoogleSync(tempArray);
                            }
                        };

                        newValue.loadComplete = function () {
                            
                            var ids = $(this).jqGrid('getGridParam', 'selarrrow');
                            processIds(this, ids);
                            $('select[id^="sync_"]').each(function () {
                                var previous = '';
                                $(this).on('click', function () {
                                    // Store the current value on focus and on change
                                    previous = $(this).val();
                                }).change(function (val) {
                                    var id = "",timeValue = 0;
                                    $('select[id^="sync_"] option:selected').each(function () {
                                        timeValue += $(this).val();
                                        id = $(this)[0].parentNode.id;
                                        id = id.replace('sync_', '');
                                    });
                                    $(this).scope().syncTimeUpdate(id, timeValue);
                                });
                            });

                            $(".account-disconnected-info-circle-base").hover(function (e) {
                                    $(this).tooltipster({ side: 'right', theme: 'tooltipster-shadow', animationDuration: 0 });
                                    $(this).tooltipster('open').tooltipster('content', $('<lable>Failed to connect</lable><p>A previous attempt to connect </p><p></p><p>to your google account was unsucessful.</p><p> Click on the reconnect button </p><p> to login to your Google account.</p>'));
                                },
                               function () {

                               });
                        };

                        $(table).jqGrid(newValue);
                    }
                });
            }
        };
    }]);

})();
'use strict';

var gridHeight = '';
var gridWidth = '';

function processIds(self, ids) {
    var actualIds = [];
    if (ids && ids.length > 0) {
        ids.forEach(function (rowId) {
            var rowObject = $(self).getRowData(rowId);
            if (rowObject)
                actualIds.push(rowObject._id);
        });
    }
    var scp = $(self).scope();
    scp.selectedRows = actualIds;
    if (!scp.$$phase)
        scp.$apply();
};

function sendQMail(email, sid) {
    window.open(config.QMAIL_URL+email+'&_sid='+sid, "_blank", "toolbar=yes, scrollbars=yes, resizable=yes, top=200, left=500, width=700, height=600");
}

app.directive('ngJqGrid', ['$cookies',function ($cookies) {
    return {
        restrict: 'E',
        scope: {
            config: '=',
            userdata: '=',
        },
        link: function (scope, element, attrs) {
            var table;
            var pager;
            var id = attrs.idElm;
            scope.$watch('config', function (newValue) {
                if(newValue){
                    $('#' + id).remove();
                    $('#pager' + id).remove();
                    element.children().empty();
                    table = angular.element('<table id="' + id + '"></table>');
                    
                    element.append(table);
                    newValue.viewrecords = true;
                    newValue.altRows = true;
                    newValue.loadonce = false;
                    newValue.shrinkToFit = false;
                    newValue.autowidth = true;

                    if (id != 'history-grid') {
                        newValue.multiselect = true;
                        newValue.multiboxonly = true;
                       pager = angular.element('<div id="pager' + id + '"></div>');
                        element.append(pager);
                        newValue.pager = '#pager' + id;
                        // newValue.beforeSelectRow = function(rowid, e) {
                        //    return $(e.target).is('input[type=checkbox]');
                        // };
                    } 
                    newValue.onSelectAll = function (ids, status) {
                        var rowIds = [];
                        if (status)
                            rowIds = ids;
                        processIds(this, rowIds);
                    };
                    newValue.onSelectRow = function (row, status, elem,e,r,f) {
                        var params = {};
                        var action = "";
                        if ($(elem.toElement).hasClass('sendQMail')) {
                            action = 'sendQMail';
                        }
                        if ($(elem.toElement).hasClass('delete')) {
                            $("#"+id).resetSelection(row);
                            action = 'delete';
                            params.is_active = $(elem.toElement).hasClass('true') ? false : true;
                        }
                        if ($(elem.toElement).hasClass('private')) {
                            $("#"+id).resetSelection(row);
                            action = 'private';
                            params.is_locked = $(elem.toElement).hasClass('true') ? false : true;
                        }
                        if ($(elem.toElement).hasClass('favorite')) {
                            $("#"+id).resetSelection(row);
                            action = 'favorite';
                            params.is_favorite = $(elem.toElement).hasClass('true') ? false : true;
                        }
                        if ($(elem.toElement).hasClass('edit')) {
                            $("#"+id).resetSelection(row);
                            action = 'edit';
                        }
                        
                        if (action != "") {
                            $(this).scope().onSelectRow($(this).scope(), action, params, $(this).getRowData(row)._id);
                        } else {
                            var ids = $(this).jqGrid('getGridParam', 'selarrrow');
                            processIds(this, ids);
                        }
                        if(!$(elem.target).hasClass('cbox'))
                            $("#"+id).resetSelection(row);
                    };
                    newValue.onPaging = function(pgButton, event){
                        if (pgButton == "user") {
                            // find out the requested and last page
                            var lastPage = $(this).getGridParam("lastpage");
                            
                            // if the requested page is higher than the last page value 
                            if (isNaN(event.value) || event.value > lastPage) {
                                $(this).setGridParam({page:lastPage}).trigger("reloadGrid");
                                return 'stop';
                            }
                          }
                        $(this).scope().updatePaginationConfiguration({pagination: event.value});
                    };
                    newValue.loadComplete = function () {
                        var ids = $(this).jqGrid('getGridParam', 'selarrrow');
                        processIds(this, ids);
                        if (id == 'contact-grid' && $(this).scope()) {
                            $(this).scope().load_groups();
                            $(this).scope().set_groups_menu();
                        }
                                
                        $('select[id^="email_"]').each(function() {
                            var previous = '';
                            $(this).on('click', function () {
                                // Store the current value on focus and on change
                                previous = $(this).val();
                            }).change(function(){
                                $(this).scope().sendQMail($(this), previous);
                            });
                        });

                        $('.ui-jqgrid-bdiv').scrollTop(0);
                        if (id == 'contact-grid' && $(this).scope().menu.trash != "selected") {
                            $("#"+id).jqGrid('hideCol', 'updated_on');
                        }

                        if (id == 'importPreviewGrid') {
                            $("#"+id).jqGrid('hideCol', 'cb');
                        }

                        $(".profile-pic").hover(function(e){
                            $(this).tooltipster({side: 'right', theme: 'tooltipster-shadow', animationDuration: 0});
                            $(this).tooltipster('open').tooltipster('content', $('<img src="'+this.src+'" height="100" width="100" />'));
                        },
                        function(){

                        });
                        if (id=='contact-grid') {
                            $(this).scope().setConfiguration();
                        }
                    };
                    gridHeight = (attrs.gridHeight != undefined) ? attrs.gridHeight : $(window).innerHeight() - 220;
                    if (id == 'history-grid')
                        gridHeight = gridHeight + 45;
                    gridWidth = (attrs.gridWidth != undefined) ? attrs.gridWidth : $(window).innerWidth();

                    $('#' + id).jqGrid(newValue);
                    $('#' + id).jqGrid('navGrid', '#pager' + id, {add: false, edit: false, del: false, search: false, refresh: false},
                            {}, {}, {}, {multipleSearch: true, multipleGroup: true, showQuery: true});
                    $('#' + id).jqGrid('setGridHeight', gridHeight);
                    $('#' + id).jqGrid('setGridWidth', 'auto');
                    $('#' + id).jqGrid('setFrozenColumns');
    //                Below code is for column chooser.
    //                $('#' + id).jqGrid('navButtonAdd', '#pager' + id, {
    //                    caption: "",
    //                    buttonicon: "ui-icon-calculator",
    //                    title: "Choose columns",
    //                    onClickButton: function () {
    //                        $(this).jqGrid('columnChooser',{
    //                            width: 260,
    //                            height: 280,
    //                            classname: "column-chooser",
    //                            msel_opts: { //multiselect options
    //                                autoOpen: true,
    //                                header: true,
    //                                height: "auto",
    //                                classes: "column-chooser",
    //                                beforeclose: function () { return false; } //keep multiselect drop down open  
    //                            }
    //                        });
    //                    }
    //                });
                }
            });
            scope.$watch('userdata', function (userdata, oldvalue) {
                $('#' + id).setGridParam({userdata: userdata}).trigger('reloadGrid');
                $('.ui-jqgrid-bdiv').scrollTop(0);
            });
            $(window).resize(function () {
                if (id != 'importPreviewGrid') {
                    gridHeight = (attrs.gridHeight != undefined) ? attrs.gridHeight : $(window).innerHeight() - 220;
                    gridWidth = (attrs.gridWidth != undefined) ? attrs.gridWidth : $(window).innerWidth() - 275;
                    if(id == 'history-grid')
                        gridHeight = gridHeight + 20;
                    $('#' + id).jqGrid('setGridHeight', gridHeight);
                    $('#' + id).jqGrid('setGridWidth', gridWidth);
                }
            });
        }
    };
}]);
'use strict';

app.directive('loading', function () {
      return {
        restrict: 'E',
        replace:true,
        template: '<div class="full-page-loader"><img src="resources/img/gif/q_loader.gif" width="20" height="20" /> Loading </div>',
        link: function (scope, element, attr) {
          scope.$watch('loading', function (val) {
              if (val)
                  $(element).show();
              else
                  $(element).hide();
          });
        }
      }
});